Documentation for developers - users read README instead!


To use the python libraries, add the findrox.py file (in this directory) to
your application and include it right at the start (from the AppRun). This
will find ROX-Lib and add ROX-Lib/python to sys.path.

You can then include the other files, eg:

	import findrox
	from rox.MultipleChoice import MultipleChoice

The following modules are provided:

	choices		- Load and save user choices
	filer		- Open directories with ROX-Filer, etc
	MultipleChoice	- A message box with buttons along the bottom
	SaveBox		- Drag and drop saving
	Toolbar		- A ROX-Filer style toolbar
	XDSLoader	- Allow files to be dropped on your widgets


choices
~~~~~~~
The Choices system is explained at:
	http://rox.sourceforge.net/choices.php3

When you want to load some settings, use:

	path = choices.load('MyProgram', 'Filename')

If path is not None then load it, else use internal defaults.

To save choices:

	path = choices.save('MyProgram', 'Filename')

If path is not None then save the choices there, else do not save (saving
is disabled at the user's request).

This creates any missing directories - pass 'create = 0' if you don't want
that (eg, to show the user where you will save without actually saving).


filer
~~~~~
You can get ROX-Filer to open a directory using:
	
	from rox import filer
	filer.open_dir('/path/to/dir')

If you want to indicate a particular file (make it flash), use:

	filer.show_file('/path/to/dir/file')


MultipleChoice
~~~~~~~~~~~~~~
This is a dialog box with a message and some buttons along the bottom.
You can use it like this:

	box = MultipleChoice('Really quit?', ['OK', 'Cancel'])
	box.set_title('Question:')
	result = box.wait()

Result is 0 if OK was chosen, 1 if Cancel was chosen and -1 if the box was
closed without a choice being made. When used this way, the box is modal
(no other widgets in your program will do anything until the user makes a
choice).

You may also specify callback functions, by using a tuple instead of a string
for a button. If you use use show() instead of wait() then the call returns
immediately and the box isn't modal.

	box = MultipleChoice('Really quit?', [('OK', mainquit), 'Cancel'])
	box.set_title('Question:')
	box.show()

Finally, you can pass extra arguments to the button callback functions, make
a callback function None to make an insensitive button and give a callback
for when the box is cancelled:

	box = MultipleChoice('Really quit?',
				[('OK', mainquit), 
				 ('Help', show_help, 'box_help'),
				 ('Crash', None),
				 'No'],
				box_cancelled)
	box.show()


SaveBox
~~~~~~~
When you want to let the user save some data somewhere, use a SaveBox.
You need to pass the constructor an object which can save, the default
filename, and the MIME type for the data, eg:

	box = SaveBox(my_doc, my_doc.uri, 'text/plain')
	box.show()

'my_doc' should have the following methods:

	set_uri(uri)
		Data is safely saved to this location, mark unmodified.
		May be omitted.

	save_get_data()
		Return a string containing the data to save.

	save_as_file(path)
		Write data to file, return TRUE on success.
		If missing, uses get_save_data() and writes that.

	save_as_selection(selection_data)
		Write data to the selection.
		If missing, uses get_save_data() and sends that.

	discard()
		Only used if discard = TRUE. Called when Discard button
		is clicked, or when data is saved safely.

If save_get_data is NOT provided, then one or both of save_as_file and
save_as_selection must be present. If only one is provided then the other
function is disabled.

If the user tries to close a document window containing modified data then you
may wish to create the savebox with 'discard = 1'. This adds a Discard button
which, if clicked, does:

	my_doc.discard()

Example:

	import findrox
	from rox.SaveBox import SaveBox
	from rox.support import report_exception
	from gtk import *

	class Doc:
		data = 'Some Text'

		def save_get_data(self):
			return self.data

	doc = Doc()

	box = SaveBox(doc, 'TextFile', 'text/plain')
	box.show()
	box.connect('destroy', mainquit)

	mainloop()

Toolbar
~~~~~~~
To add a toolbar to your application, put a VBox in the main window and
pack_start a Toolbar into it, like this:

	window = GtkWindow()
	vbox = GtkVBox(FALSE, 0)
	window.add(vbox)
	toolbar = Toolbar()
	vbox.add(toolbar)

You can then add tools to the toolbar like this:

	tool = toolbar.add_button('Quit', app_dir + '/icons/quit.xpm',
				  'This tool quits the application')
	
'Quit' is the name of the tool (not currently used, but a large
style will probably be supported at some point).

The second argument is an icon in XPM format to display in the button.
The third argument is the tooltip for the tool.

You can connect to the 'clicked' signal of 'tool' to handle clicks.

The icons are cached, not reloaded every time you create a new toolbar.

XDSLoader
~~~~~~~~~
To make a widget allow drops, add XDSLoader to its classes list and
initialise it with a list of allowed types (None prevents data being
dragged in from other applications, but still allows files):

	from rox.XDSLoader import XDSLoader

	class MyWindow(GtkWindow, XDSLoader):
		def __init__(self, filename = None):
			GtkWindow.__init__(self)
			XDSLoader.__init__(self, ['text/plain'])

When a file is dragged onto the window the method xds_load_uris() gets
called with a list of URIs to load. If you don't override it, the default
is to call xds_load_file(path) for each (local) file in the list.

If some data (not a file) is dropped on the window then
xds_load_from_selection(selection) is called.

In either case, the default methods get the data and call
xds_load_data(data).
